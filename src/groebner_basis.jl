
DP = SymbolicUtils.DynamicPolynomials

# returns the result of promotion of all itr elements types to a single one
commoneltype(x) = typeof(x)
commoneltype(arr::AbstractArray)      = commoneltype(x for x in arr)
commoneltype(itr::Base.ValueIterator) = commoneltype(x for x in itr)
commoneltype(itr::Base.Generator)     = mapreduce(commoneltype, promote_type, itr, init=Int)

#=
Converts an array of symbolic polynomials
into an array of DynamicPolynomial's
=#
function symbol_to_poly(sympolys::AbstractArray, check)
    # find all vars present in system
    vars = Any[]
    for expr in sympolys
        get_variables!(vars, expr)
    end

    # how to make polynomial_coeffs consider constants as monomials?
    # e.g. for now it says that res for x + 1 is 1, but we want
    polyforms, res = polynomial_coeffs(sympolys, vars)

    # check if constant terms do not contain any left symbolic expressions
    check && any(iswrapped, res) && error("Not a polynomial in input.")

    # discover a common coefficient type
    coefftype = commoneltype(values(pf) for pf in polyforms)
    coefftype = promote_type(coefftype, commoneltype(res))
    @assert coefftype <: Union{Integer, Rational} "Only integer and rational coefficients are supported as input."

    # is there a better criterion for sorting variables?
    sort!(vars, by=string)

    DP.@polyvar xs[1:length(vars)]

    # sym variable => poly variable
    sym2poly = Dict(v => x for (v, x) in zip(vars, xs))

    polys = Vector{DP.Polynomial{true, coefftype}}(undef, length(sympolys))
    for (i, (polyform, r)) in enumerate(zip(polyforms, res))
        polys[i] = sum(substitute(c*m, sym2poly) for (c, m) in polyform; init=r)
    end

    polys, sym2poly
end

#=
Converts a DynamicPolynomial.Polynomial into a symbolic expression
mapping variables w.r.t poly2sym
=#
function poly_to_symbol(poly, poly2sym)
    ans = zero(DP.coefficienttype(poly))
    for (c, m) in zip(DP.coefficients(poly), DP.monomials(poly))
        ans += c*prod(poly2sym[var]^p for (var, p) in DP.powers(m); init=1)
    end
    ans
end

#=
Converts an array of DynamicPolynomial.Polynomial into an array of
symbolic expressions mapping variables w.r.t poly2sym
=#
function poly_to_symbol(polys::AbstractArray, sym2poly)
    poly2sym = Dict(sym2poly[k] => k for k in keys(sym2poly))
    sympolys = Vector{Num}(undef, length(polys))
    for (i, poly) in enumerate(polys)
        sympolys[i] = poly_to_symbol(poly, poly2sym)
    end
    sympolys
end

"""

groebner_basis(polynomials; reduced=true)

Computes a Groebner basis of the ideal generated by the given `polynomials`.

If `reduced` is set, the basis is reduced and *unique*.

"""
function groebner_basis(polynomials; reduced=true, check=true)
    system, sym2poly = symbol_to_poly(polynomials, check)

    basis = groebner(system, reduced=reduced)
    println(basis)

    poly_to_symbol(basis, sym2poly)
end
